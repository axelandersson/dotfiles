#!/usr/bin/perl -w

use strict;
use CLI;
use CLI::File;
use Text::Autoformat;

my $options = CLI::options("dryrun|n");
my $command = shift @ARGV;
my @files = @ARGV;

CLI::usage("[--dryrun|-n] <command> <file> [<file> ...]", "Commands: 's/foo/bar/g' 'uppercase' 'lowercase' 'titlecase'") if $options->{"help"} || !$command || @files == 0;

my $regexp;
my $autoformatcase;

if($command =~ /^s\/.*?\/.*?\/\w*$/) {
    $regexp = $command;
}
elsif($command eq "uppercase" || $command eq "upper" || $command eq "uc") {
    $autoformatcase = "upper";
}
elsif($command eq "lowercase" || $command eq "lower" || $command eq "lc") {
    $autoformatcase = "lower";
}
elsif($command eq "titlecase" || $command eq "title" || $command eq "tc") {
    $autoformatcase = "highlight";
}

CLI::asserttrue($regexp || $autoformatcase, "Command \"$command\" not recognized");

foreach my $path (@files) {
    my $newpath = renamedpath($path, $regexp, $autoformatcase);

    if($path eq $newpath) {
        println "$path -> $newpath: No change";
    }
    elsif($options->{"dryrun"}) {
        println "$path -> $newpath: OK (Dry run)";
    }
    elsif(CLI::File::move($path, $newpath)) {
        println "$path -> $newpath: OK";
    }
}



sub renamedpath {
    my $path = shift;
    my $regexp = shift;
    my $autoformatcase = shift;

    my $olddirectory = CLI::pathbydeletinglastpathcomponent($path);
    my $oldname = CLI::lastpathcomponent($path);
    my $newname;

    if($regexp) {
        $newname = $oldname;
        eval("\$newname =~ $regexp;");
    }
    elsif($autoformatcase) {
        $newname = autoformat($oldname, { "case" => $autoformatcase });
        $newname =~ s/\s+$//s;
        $newname =~ s/(\.[\w\d]+)$/lc($1)/ei;
    }

    if($olddirectory eq ".") {
        return $newname;
    } else {
        return CLI::pathbyappendingpathcomponents($olddirectory, $newname);
    }
}
